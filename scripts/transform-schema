#!/usr/bin/env python3

"""
Accept a template schema on stdin and transform it before writing to stdout.

Transformations applied:
  * Inject default metadata fields
  * Allow nulls for non-required fields

Expects the target schema path to be passed as a command-line argument.
"""

import argparse
from collections.abc import Mapping
import json
from pathlib import Path
import sys

MOZ_PIPELINE_METADATA = "mozPipelineMetadata"
TEMPLATES_DIR = Path(__file__).parent.parent / "templates"


def merge_where_empty(a, b):
    """Recursively merge b into a where items are missing in a."""
    for key, b_value in b.items():
        a_value = a.get(key)
        if a_value is None:
            a[key] = b_value
        elif isinstance(a_value, Mapping) and isinstance(b_value, Mapping):
            merge_where_empty(a_value, b_value)


def allow_null_nonrequired_properties(schema):
    """Add "null" as an allowed type for non-required properties if it isn't already present."""
    required_properties = set(schema.get("required", []))
    for validations_name in ("allOf", "anyOf", "oneOf"):
        for validation_schema in schema.get(validations_name, []):
            required_properties.update(validation_schema.get("required", []))
            allow_null_nonrequired_properties(validation_schema)

    for property_name, property_schema in schema.get("properties", {}).items():
        if property_name not in required_properties and not property_name.startswith("$"):
            property_type = property_schema.get("type")
            if isinstance(property_type, str) and property_type != "null":
                property_schema["type"] = [property_type, "null"]
            elif isinstance(property_type, list) and "null" not in property_type:
                property_type.append("null")
            # If an `enum` is defined, a literal null value must be added to it (`None` in Python).
            property_enum = property_schema.get("enum")
            if property_enum and None not in property_enum:
                property_enum.append(None)
        allow_null_nonrequired_properties(property_schema)

    items = schema.get("items")
    if isinstance(items, dict):
        allow_null_nonrequired_properties(items)
    elif isinstance(items, list):
        for item in items:
            allow_null_nonrequired_properties(item)
    for prefix_item in schema.get("prefixItems", []):
        allow_null_nonrequired_properties(prefix_item)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("target")
    args = parser.parse_args()

    fileparts = Path(args.target).parts
    schema_basename = fileparts[-1]
    doctype = fileparts[-2]
    namespace = fileparts[-3]

    # Parse the schema and extract metadata.
    schema = json.load(sys.stdin)
    meta = schema.get(MOZ_PIPELINE_METADATA, {})
    propagate_metadata = bool(meta)
    inject_default_metadata = True

    # Namespace-level defaults.
    defaults_path = TEMPLATES_DIR / namespace / "defaults.schema.json"
    if defaults_path.exists():
        with open(defaults_path) as f:
            namespace_defaults = json.loads(f.read()).get(MOZ_PIPELINE_METADATA, {})
            if namespace_defaults is False:
                # A namespace defaults file that sets '"mozPipelineMetadata" = false'
                # is a special flag to exempt the namespace from metadata injection.
                inject_default_metadata = False
            else:
                propagate_metadata = True
                merge_where_empty(meta, namespace_defaults)
    else:
        propagate_metadata = True

    # Prepare some default metadata if not overridden in the template schema.
    if inject_default_metadata:
        bq_dataset_family = namespace.replace("-", "_")
        bq_doctype = doctype.replace("-", "_")
        version = schema_basename.split(".")[1]
        bq_table = "{}_v{}".format(bq_doctype, version)
        defaults = {
            "bq_dataset_family": bq_dataset_family,
            "bq_table": bq_table,
            "bq_metadata_format": "structured",
        }
        merge_where_empty(meta, defaults)
    if propagate_metadata:
        schema[MOZ_PIPELINE_METADATA] = meta
    else:
        schema.pop(MOZ_PIPELINE_METADATA, None)

    allow_null_nonrequired_properties(schema)

    # Output.
    json.dump(schema, sys.stdout, sort_keys=True, ensure_ascii=False, indent=2)

    # Make sure we end the file with a newline.
    print("")
